# Agent prompt: Sync website Creature Avatar hash with Fonsters app

## Goal

Update the **website** at https://nathanfennel.com/games/creature-avatar so that its Creature Avatars are **identical** to the creatures generated by the Fonsters iOS/macOS app for the same input string (seed). The app uses a hash-once-then-slice architecture; the website must match exactly.

## Architecture: Hash once, use different parts

1. **Hash the seed ONCE** → 256 bits (8 × 32-bit lanes). Every character in the seed contributes. The string is never used directly; only its hash.
2. **For each segment** (palette, eyes, mouth, etc.) → The `segmentId` selects *which combination* of those 256 bits we use. The segmentId is hashed to a mixer; the mixer XORs into the lanes before combining.
3. **Any change to the string** changes the entire 256-bit hash, so all segments get new values.

## Hash implementation (match the app exactly)

### 1. Seed hash: `seedHash256(seed)` — hash ONLY the seed

- **Input**: `seed` (string). Do NOT append segmentId here.
- Initialize 8 lanes: `[5381, 5382, 5383, 5384, 5385, 5386, 5387, 5388]`.
- Iterate over **UTF-16 code units** of `seed` (in order). For each code unit at index `i`:
  - `low = codeUnit & 0xFF`, `high = (codeUnit >> 8) & 0xFF`
  - For each lane 0..7: `k = (i * 31 + lane * 17)` (32-bit unsigned)
  - `lanes[lane] = mix32(lanes[lane], low ^ (k & 0xFF))` then `lanes[lane] = mix32(lanes[lane], high ^ ((k >> 8) & 0xFF))`
  - Each character updates ALL 8 lanes (no `i % 8`); length is never used.
- `mix32(h, byte) => ((h << 5) + h) ^ byte` (32-bit unsigned)
- Apply **fmix32** to each lane:
  ```
  fmix32(h) {
    k = h
    k ^= k >>> 16
    k = (k * 0x85ebca6b) >>> 0
    k ^= k >>> 13
    k = (k * 0xc2b2ae35) >>> 0
    k ^= k >>> 16
    return k
  }
  lanes[i] = fmix32(lanes[i])  // for i 0..7
  ```
- Return `(l0, l1, l2, l3, l4, l5, l6, l7)`.

### 2. Segment mixer: `segmentMixer53(segmentId)` — 53-bit from segmentId

- `lo = 5381`, `hi = 5381`
- For each byte of `segmentId` in UTF-8 at index j: if j even, `lo = ((lo << 5) + lo) ^ byte`; else `hi = ((hi << 5) + hi) ^ byte` (32-bit unsigned)
- Apply fmix32 to both; return 53 bits: `(fmix32(hi) << 21) | (fmix32(lo) >>> 11)`

### 3. `segmentHash(seed, segmentId)` — value in [0, 1)

- `(l0..l7) = seedHash256(seed)` — from seed only
- `m53 = segmentMixer53(segmentId)`
- Extract 8 values (6 bits each): `m0 = (m53 >> 0) & 0x3F`, `m1 = (m53 >> 6) & 0x3F`, ..., `m7 = (m53 >> 42) & 0x3F`
- Mix: `l0m = l0 ^ (m0 * 0x01010101)`, ..., `l7m = l7 ^ (m7 * 0x01010101)` (32-bit unsigned)
- `low = l0m ^ l2m ^ l4m ^ l6m`
- `high = l1m ^ l3m ^ l5m ^ l7m`
- `top53 = (high << 21) | (low >>> 11)`
- **Uniformity finalizer (required):** `top53 = (top53 * 0x9E3779B97F4A7C15) >>> 11` (64-bit unsigned multiply, then unsigned right shift). This ensures `segmentHash` is uniformly distributed in [0, 1) so feature probabilities (mouth, nose, body, eyebrows, etc.) trigger as intended.
- `return top53 / 9007199254740992.0`  // 2^53

### 4. `segmentPick(seed, segmentId, n)` and `segmentRoll(seed, segmentId, p)`

- `segmentPick`: `floor(segmentHash(seed, segmentId) * n) % n`
- `segmentRoll`: `segmentHash(seed, segmentId) < p`

## Success criteria

- For any string S, the creature on the website for seed S is **pixel-identical** to the Fonsters app.
- Changing a single character (e.g. "Jonathan Lora" → "Jonathan Lord") produces a completely different creature.

## Reference

- **File**: `Fonsters/CreatureAvatar/CreatureHash.swift`
- **Functions**: `seedHash256`, `segmentMixer53`, `segmentHash`, `segmentPick`, `segmentRoll`
