# Agent prompt: Sync website Creature Avatar hash with Fonsters app

## Goal

Update the **website** at https://nathanfennel.com/games/creature-avatar so that its Creature Avatars are **identical** to the creatures generated by the Fonsters iOS/macOS app for the same input string (seed). The app was updated with a hash fix; the website must use the same hash logic.

## Context

- **Fonsters app**: Deterministic creature avatars from a text seed. Same seed → same 32×32 creature. The app’s hash lives in `Fonsters/CreatureAvatar/CreatureHash.swift`.
- **Website**: The “Creature Avatar” web app at the URL above should produce the **exact same** creature image for a given seed string so that shared links and exported seeds look the same everywhere.

## Required change on the website

The app’s **segment hash** (the function that turns `seed + segmentId` into a value in [0, 1)) was updated so that **all 8 lanes** of the internal 256-bit hash affect the 53-bit output. The website likely still uses the **old** behavior, which only used lanes 0 and 1. That caused many seeds (e.g. long strings like ISO8601 timestamps) to produce the same creature for several characters in a row when only one character changed.

Update the website’s equivalent of `segmentHash` (the function that takes a seed string and a segment id and returns a number in [0, 1)) to match the app’s **current** behavior below.

### Hash behavior to implement (match the app exactly)

1. **Input**: `seed` (string), `segmentId` (string).  
   **Combined string**: `combined = seed + "\0" + segmentId`  
   (Use a single null character between seed and segmentId.)

2. **256-bit hash (8 × 32-bit lanes)**  
   - Initialize 8 lanes: `[5381, 5382, 5383, 5384, 5385, 5386, 5387, 5388]` (DJB2-style init).  
   - Iterate over the **UTF-16 code units** of `combined` (in order). For each code unit at index `i`:  
     - Lane index: `lane = i % 8`.  
     - Low byte: `low = codeUnit & 0xFF`.  
     - High byte: `high = (codeUnit >> 8) & 0xFF`.  
     - Update: `lanes[lane] = mix32(lanes[lane], low)` then `lanes[lane] = mix32(lanes[lane], high)`.  
   - Mix function (32-bit): `mix32(h, byte) => ((h << 5) + h) ^ byte` (use unsigned 32-bit arithmetic; in JavaScript ensure >>> 0 or equivalent so it stays 32-bit).

3. **53-bit value from the 8 lanes (this is the fix)**  
   - Combine lanes with XOR (not only lanes 0 and 1):  
     - `low  = l0 ^ l2 ^ l4 ^ l6`  
     - `high = l1 ^ l3 ^ l5 ^ l7`  
   - Then:  
     - `top53 = (high << 21) | (low >>> 11)`  
     (Use 53-bit-safe integer math; in JS, use Number or BigInt so that `top53` is in [0, 2^53).)

4. **Return value**:  
   - `return top53 / 9007199254740992.0`  
   (i.e. divide by 2^53 so the result is in [0, 1).)

### What was wrong before (do not do this on the website)

- **Old (wrong)** behavior: `top53 = (l0 << 21) | (l1 >>> 11)` — only lanes 0 and 1 were used.  
- **New (correct)** behavior: XOR all 8 lanes into two groups (even lanes → `low`, odd lanes → `high`), then `top53 = (high << 21) | (low >>> 11)`.

So on the website, find where the 53-bit value is computed from the eight lanes and change it to use the XOR combination of all 8 lanes as above. Keep everything else (DJB2 init, UTF-16 iteration, mix32, segmentId concatenation with `\0`, and division by 2^53) the same as the app.

## Success criteria

- For any string S, the creature image rendered on the website for seed S is **pixel-identical** (or visually identical) to the creature image produced by the Fonsters app for the same seed S.  
- In particular, changing or adding a single character anywhere in S should change the website’s creature (no long runs of identical creatures when only one character changes, e.g. when typing an ISO8601 string).

## Reference: app source

The authoritative implementation is in this repo:

- **File**: `Fonsters/CreatureAvatar/CreatureHash.swift`
- **Functions**: `stringHash256`, `segmentHash`, `segmentPick`, `segmentRoll`

Use that file as the single source of truth for the hash and segment logic when in doubt.
